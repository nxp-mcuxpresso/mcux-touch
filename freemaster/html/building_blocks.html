<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NXP Touch Library Reference Manual: Key library elements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NXP Touch Library Reference Manual
   &#160;<span id="projectnumber">Rev 2.0</span>
   </div>
   <div id="projectbrief">NXP Semiconductors, Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('building_blocks.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Key library elements </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section explains the vital building blocks of the NXP Touch Library used in the user application.</p>
<p>The NXP Touch library is based on a layered architecture with data types resembling the object-oriented approach, however, it is still implemented in a plain C language. The basic building blocks are outlined in the following figure. Each block is further described in the <b>Reference</b> section.</p>
<div class="image">
<img src="Touch_lib.png" alt="Touch_lib.png"/>
<div class="caption">
Object structure</div></div>
<ul>
<li><a class="el" href="building_blocks.html#system_section">System</a> (System API): The general code of NT to provide basic functionality for the user application.<ul>
<li><a class="el" href="building_blocks.html#part_of_system">Crosstalk</a> (System API): The system software layer provides the crosstalk processing to reduce the interferences or influences among neighboring electrodes.</li>
<li><a class="el" href="building_blocks.html#grounding_of_adjacent_TSI_channels">Grounding or shielding of adjacent TSI channels</a> (General API) - Grounding or shielding of adjacent TSI channels feature</li>
</ul>
</li>
<li><a class="el" href="building_blocks.html#module_section">Modules</a> (<a class="el" href="group__modules.html">Modules</a> API): The modules are designed for hardware interaction and gathering of capacitance data.<ul>
<li><a class="el" href="building_blocks.html#random_electrode_order">Random electrodes order</a> (<a class="el" href="group__modules.html">Modules</a> API): Random electrodes order feature</li>
</ul>
</li>
<li><a class="el" href="building_blocks.html#keydetector_section">Key detectors</a> (<a class="el" href="group__detectors.html">Key Detectors</a> API): The key detectors are designed to recognize the touch/release events from the data measured by the modules.</li>
<li><a class="el" href="building_blocks.html#controls_section">Controls</a> (<a class="el" href="group__controls.html">Controls</a> API): The high-level objects represent the so-called “Decoder” and are used to create virtual devices (controls) from the individual electrodes.</li>
<li><a class="el" href="building_blocks.html#electrodes_section">Electrodes</a> (<a class="el" href="group__electrodes.html">Electrodes</a> API): The electrode is a basic data container with the functionality for general control of the individual electrodes.</li>
<li><a class="el" href="building_blocks.html#drivers_section">Drivers</a> (<a class="el" href="group__tsi__drivers.html">TSI Drivers</a> API or <a class="el" href="group__cs__drivers.html">CS Drivers</a> API): These drivers control the TSI periphery. The driver has the following two parts: -Common part -Version-dependent part</li>
</ul>
<h1><a class="anchor" id="system_section"></a>
System</h1>
<p>The main object encapsulates the lists of the other key objects used in the NXP Touch system, such as the measurement modules and controls. There is always only one active instance of the System object in the application. The System function API covers the initialization, global timing, and uniform access to the touch-detection modules.</p>
<h2><a class="anchor" id="part_of_system"></a>
Crosstalk</h2>
<p>The essence of capacitive sensing regardless of the self-capacitance or mutual-capacitance sensing methods is to measure the capacitive change caused by a finger. The mutual interferences among at least two electrodes are inevitable. The magnitude of interferences depends on a lot of factors, for example, electrode distance, electrode area, or finger or stylus surface. The influence of mutual electrodes can cause an unintentional touch event. Therefore, the development of the <b>crosstalk reduction</b> feature in the NXP Touch library can help solve such problems. The benefit of the crosstalk reduction is a more reliable touch or release detection but more calculation power is required to achieve it.</p>
<p>The crosstalk reduction system is based on adjusting the delta signals from the touch or release events. The delta signal mutual reduction is built on the knowledge of mutual influencing relations among adjacent electrodes. The described crosstalk initialization process is called <b>crosstalk adaptation</b> and must be done with user contribution. The adaptation phase requires making touch with the defined length and several touches for all crosstalk reduction electrodes. The crosstalk reduction can be processed for a maximum of four electrodes on the CM0+ cores because the matrix calculations become difficult with the crosstalk electrode number. The crosstalk is not symmetric, implying that the influence between electrodes is different and depends on the direction from the touched electrode to the affected one. Finger slope causes the crosstalk when the fingertip touches an electrode and the other electrode detects increased proximity from the rest of the finger, as shown in the </p>
<div class="image">
<img src="crosstalk0.png" alt="crosstalk0.png"/>
<div class="caption">
Cross-talk creation example.</div></div>
<div class="image">
<img src="crosstalk0.png" alt="crosstalk0.png"/>
<div class="caption">
Cross-talk creation example</div></div>
<p>The crosstalk software layer is integrated into the Touch library as the independent software module triggered from the higher system layer processing the measured delta signal from the electrodes. The new reduced delta values are replaced and stored in the electrodes for processing in key detectors. Such a principle can also reduce crosstalk for electrodes associated with different modules - different TSI peripherals.</p>
<p>The principle of how the crosstalk reduces and adapts the data is based on the following: The crosstalk inputs are signals measured after baseline subtractions. The number of inputs can be 2, 3, or 4 arbitrary electrodes. &lt;Note&gt;: The input signals can be maximum because it is computationally acceptable for the Arm Cortex M0+ core-based devices with a TSI peripheral.&lt;/Note&gt; The crosstalk transformation algorithm derived from the <b>Activation model</b> is applied to the delta input vector and the crosstalk result is the delta vector with the crosstalk reduced. The crosstalk result vector update is recalculated each time the delta input vector is updated (the data ready flag is set). If the user requests, the Activation model and the transformation computing can be updated. This case is rare because the mutual influence among electrodes does not change much.</p>
<p>The Activation model comprises a square <b>activation matrix</b>, where each row represents an activation profile when the electrode is touched. The main diagonal shows the highest activation delta signal of the touched electrode. The other parts of the activation matrix show the crosstalk effect. Each cell of the activation matrix is scaled to get the maximum positive signed integer 16-bit values on the main diagonal.</p>
<p>The crosstalk layer consists of three selectable processes:</p>
<ul>
<li><b>Adaptation</b>: The sensing process measuring the crosstalk intensity to see how the electrode signals interact with each other. The process can be turned ON or OFF:<ul>
<li>ON: The adaptation state requires the user to touch all crosstalk electrodes one or more times to define the activation profiles for each electrode. During the adaptation process, the activation matrix is rewritten.</li>
<li>OFF: There is no crosstalk adaptation process and no update of the activation matrix.</li>
</ul>
</li>
<li><b>Adaptation request</b>: A single option selection (ON option) to determine that the finished adaptation process wants to recalculate the inverse matrix from the activation matrix. After recalculating the state of the adaptation request, the process is automatically set to OFF.</li>
<li><b> reduction </b>:<ul>
<li>ON - Turns on the crosstalk reduction. The delta signals recalculated by the crosstalk reduction function are used for the touch-sensing processes.</li>
<li>OFF - Turns off the crosstalk reduction. The crosstalk reduction process does not update the signals.</li>
<li>OFF_show - Turns on the crosstalk reduction but the reduced delta signals are shown only in FreeMASTER and not pushed to the key detector or other processing of the Touch library. This option is suitable to check the adaptation result without using the crosstalk reduction functionality in another touch software layer.</li>
</ul>
</li>
</ul>
<p>The <b>transformation matrix</b> calculates the crosstalk transform. This matrix is a square matrix, transforming a <b>raw activation profile</b> into a <b> new activation profile</b>. The activation profile is raw in the matrix when the electrode is touched. The ideal activation matrix where all crosstalk is removed is the diagonal matrix with all cells being zero, except for the main diagonal cells. The transformation matrix is calculated as the <b>inverse matrix</b> of the peak-normalized activation matrix.</p>
<p>The <b>calibration</b> is the process to obtain the crosstalk activation matrix. The activation matrix defines the complexity of the crosstalk reduction. When the activation profile is not precise enough, the calculated inverse matrix reacts to invalid input electrode interactions. The activation matrix can be written as a static single-dimension array where the matrix cells are row aligned and assigned to the actMat member of the <a class="el" href="group__xtalk.html#structnt__system__xtalk__params">nt_system_xtalk_params</a> config structure. Another way to obtain the activation matrix is to measure it for a specific board. The user is required to make the touches to finish the adaptation process. The environmental changes (temperature and humidity) or a production spread (changes across samples in parasitic capacitances, mechanical changes) must influence the crosstalk precision. Therefore, the activation profile update must be taken into account. The procedures to obtain the activation matrix are as follows:</p>
<ul>
<li><b>Fixed transform</b>: The activation matrixes are measured for several panels or boards of the same type. The particular activation matrixes must be averaged to the final activation matrix used for all panels or boards.</li>
<li><b>Sample-calibrated transform</b>: Each panel or board is calibrated as a standalone by an operator in the factory. The configuration for each panel or board is different, making this case more precise but requiring more operator effort and time.</li>
<li><b>Adaptive transform</b>: This option is based on the fixed transform for obtaining the average activation matrix, but during the board or panel operation, the user updates the activation profiles for each crosstalk electrode at each release event in the case of a single touch. After a defined period or number of touches, the transformation matrix can be computed and used for the crosstalk reduction.</li>
</ul>
<p>The following example demonstrates the crosstalk capability to reduce the interferences and mutually influence the raw signals among electrodes. The upper block consists of four mutual sensing electrode delta signals showing four touches on each electrode with crosstalk during the touch event (delta signals from untouched electrodes). The lower block shows the reduced crosstalk on each electrode delta signal when the electrode is touched. Notice that all delta signals except for the touched ones are reduced almost to zero delta during the touch, showing outstanding crosstalk reliability under the condition of the correct adaptation and with the parameter nt_xtalk_neighbours set to 4 neighbors (maximum). This means that all four crosstalk electrodes are used for crosstalk reduction.</p>
<div class="image">
<img src="crosstalk1.png" alt="crosstalk1.png"/>
<div class="caption">
Cross-talk reduction example</div></div>
<p>In the variable watch window, the following crosstalk-supporting arrays and variables are shown:</p>
<ul>
<li><b>actMat[0..N]</b>: The activation matrix is defined as a one-dimensional static array form with size N = 3 or 8 or 15 for 2, 3, or 4 electrode crosstalk. The array is defined in the nt_setup.c file and updated after a touch event longer than defined in the nt_xtalk_adapt_touch_time structure member of the nt_xtalk_params xtalk parameter.</li>
<li><b>profile_accu_count</b>: The variable measuring the duration of the touch event. It is required to update the activation profile, that is, one row of the activation matrix.</li>
<li><b>xtalk_adapt_on</b>: The boolean static variable can be set to ON or OFF for the adaptation process to turn ON or OFF. The adaptation process requires user activity to make step-by-step touches on all crosstalk electrodes.</li>
<li><b>xtalk_reduction_enabled</b>: The boolean static variable can be set to ON, OFF, or OFF_show to turn the crosstalk reduction ON or OFF. The OFF_show option is a specific case when the crosstalk delta signals are calculated but not used in the higher touch layers.</li>
<li><b>xtalk_request_adapt</b>: The boolean static variable can be set to ON and if it is requested to recalculate the inverse matrix, it automatically sets to OFF.</li>
</ul>
<h1><a class="anchor" id="module_section"></a>
Modules</h1>
<p>This section describes the different <a class="el" href="group__modules.html">Modules</a> supported by the NXP Touch library.</p>
<p>The modules are a part of the NT code that secures the gathering of raw data from the NXP TSI or CS peripheral. The module describes the hardware configuration and control of the elementary functionality of the TSI peripheral by a generic, low-level driver API. The module also handles the noise_mode mode supported by TSI v4 (Kinetis K32L2A). All the different modules are implemented using the same API function. Users do not need to worry about the differences between individual TSI versions. All modules behave as a TSI without any difference.</p>
<h2><a class="anchor" id="random_electrode_order"></a>
Random electrodes order</h2>
<p>The random electrode order feature led to the randomization of the electrode measuring order in each loop of all electrode sensing.</p>
<p>A false touch detection can occur when an external signal influences the TSI measurement as shown in the following figure. Electrode 2 measures the positive peaks (samples) from the pulse, resulting in an almost constant delta signal. The delta signal is evaluated as a touch event not caused by the finger but caused by disturbance or an interference external signal event. After randomization of measuring order, these peaks from the pulses are spread over all electrodes of the module randomly. This results in suppression of the effect on the smooth baseline signals of the electrode as shown in the following figure. By using multiple key filters of the detector (for example, delta length debounce), these peaks can be further filtered and even eliminated. The more electrodes are assigned to a module, the better the functionality of the feature. The <b><em>elec_random_order</em></b> parameter enables the random electrode order feature and can be selected separately for each module. If the <b><em>elec_random_order</em></b> is disabled, The original constant descending electrode measuring order is used.</p>
<div class="image">
<img src="random_elec_order.png" alt="random_elec_order.png"/>
<div class="caption">
Random electrodes order</div></div>
<h2><a class="anchor" id="type_of_modules"></a>
Module types</h2>
<p>The NT library defines <b><a class="el" href="group__tsi.html">TSI module</a></b> or <b><a class="el" href="group__cs.html">CS module</a></b>. The module gathers the physical electrode capacitance data from the TSI peripheral. It is based on the MCUXpresso SDK driver. The TSI module also contains a simple key detector for the noise mode (if it is enabled) and it runs on the TSI v4 peripheral version. &lt;Note&gt;: The special noise mode is a hardware feature of the TSI module version 4. The module is implemented in the Kinetis KE32L2A MCU.&lt;/Note&gt;</p>
<h1><a class="anchor" id="keydetector_section"></a>
Key detectors</h1>
<p>This section describes the different <a class="el" href="group__detectors.html">Key Detectors</a> supported by the NXP Touch library. The key detector module determines whether an electrode has been touched or released according to the values obtained by the capacitance-sensing layer. Along with this detection, to prevent the library from false touch, the key detector module uses a debouncing algorithm.</p>
<h2><a class="anchor" id="type_of_keydetectors"></a>
Types</h2>
<p>The NT library defines the objects of the key detectors compound of the following division:</p>
<ul>
<li><p class="startli"><b>AFID</b>: The Advanced Filtering and Integrating Detection key detector operates using two IIR filters with different depths (one being short/fast, the other being long/slow). It then integrates the difference between the two filtered signals. Although this algorithm is more immune to noise, it is not compatible with other noise-cancellation techniques, such as shielding. The AFID key detector can be manually selected in the NT configuration. The key detector also provides automatic sensitivity calibration. The calibration periodically adjusts the level of the electrode sensitivity, which is calculated according to the touch-tracking information. Although the sensitivity must no longer be set manually, the settings are still available for more precise tuning. The standard baseline, which is set according to the low-pass IIR filter, is also calculated for the analog decoders and the proximity function. A debounce function is implemented in this module to eliminate the false detections caused by instantaneous noise.</p>
<p class="startli">The main functions of the AFID key detector module are as follows:</p>
<ul>
<li>Two filters with the integration for touch detection</li>
<li>Electrode detection debouncing</li>
<li>Baseline generation</li>
<li>IIR filtering of the current capacitance signal</li>
<li>Proximity detection</li>
<li>Sensitivity autocalibration</li>
<li>Electrode status reporting</li>
<li>Fault reporting</li>
</ul>
<div class="image">
<img src="afid_traces.png" alt="afid_traces.png"/>
<div class="caption">
AFID key detector signals</div></div>
 </li>
<li><p class="startli"><b>SAFA,uSAFA</b>: The Signal Adaptive Filtering Algorithm key detector operates by calculating three auxiliary signals (Adaptive baseline, Predictive signal, and Noise signal). The raw measured signal is filtered using these signals. The SAFA key detector can handle signals that vary in level, polarity, and offset to zero. In the release state, there is the Adaptive Baseline signal following the Measured signal. There is the Dead Band proportional to the actual Noise signal and the signal-to-noise ratio around the Baseline signal. When the Measured signal leaves the Dead Band, the Touch event is detected. The Predicted signal is then calculated and almost reaches the Measured signal. When the Measured signal decreases under the Predicted signal, the Release event is detected. The SAFA key detector can be manually selected in the NT configuration. The SAFA key detector is recommended to pass the harsh EMC environment and EMC bench tests like the Conducted Immunity test (IEC61000-4-6). <b>uSAFA</b> is the "uni-directional" version of the SAFA key detector, which, unlike the standard SAFA, evaluates just the positive delta signal changes as a valid touch event, while the negative signal drops are ignored. uSAFA is recommended for usage with TSIv5, available on the Kinetis KE1x family.</p>
<p class="startli">The SAFA algorithm components are as follows:</p>
<ul>
<li>Adaptive baseline calculation</li>
<li>Predictive signal calculation</li>
<li>Noise signal calculation</li>
<li>The Dead Band filter</li>
<li>Moving average Filters</li>
</ul>
<div class="image">
<img src="safa_signal.png" alt="safa_signal.png"/>
<div class="caption">
SAFA key detector signal diagram</div></div>
 </li>
<li><p class="startli"><b>MBW</b>: The Minimum Baseline Window tracking key detector is the most powerful and fully configurable key detector based on the uSAFA key detector, but the baseline signal is filtered and adapted using a different method. The baseline signal is obtained from the filtered measured signal as a minimum value from a defined period. The baseline signal value lower than the minimum is replaced as a new baseline value immediately. The MBW key detector uses smooth filters to smooth out the measured signal and the baseline signal. Like uSAFA, the MBW key detector processes three auxiliary signals (Adaptive baseline, Predictive signal, and Noise signal). The MBW key detector even adjusts the baseline window adaptation during a touch event on other electrodes. The MBW key detector is required to set the following new parameters in addition to uSAFA:</p>
<ul>
<li><b><em>touch_limit</em></b>: If no or low touch event normal baseline adaptation is used, the maximum number of touches before making the baseline adaptation quicker refers to the touch limit. &lt;Note&gt;: Too many touches are probably accidental.&lt;/Note&gt;</li>
<li><b><em>tau_smooth_signal</em></b>: Smoothing time constant (in ms) for the initial fixed smoothing of signals.</li>
<li><b><em>tau_smooth_baseline</em></b>: Smoothing time constant (in ms) for baseline tracking.</li>
<li><b><em>debounce_length</em></b>: Length of the debouncing buffer (0 = no_debounce).</li>
</ul>
<p class="startli">The MBW keeps the SAFA/uSAFA basic functionality like "noise tracking" and "touch threshold adaptation", but includes some improvements:</p>
<ul>
<li>A signal smoothing method used on signals in tandem with the moving average principle, which generally improves the response time.</li>
<li>Baseline tracking window used for faster adaptation to signal/baseline drifts in both directions.</li>
<li>Selectable tau time constants for signal smoothing filters (robustness vs speed tradeoff).</li>
<li>Selectable length of the baseline tracking window in the released and touched state.</li>
<li>Legacy key detector uSAFA is still supported in the library for compatibility and tests.</li>
</ul>
<p class="startli">The MBW key detector detects the touch and release events with constant minimum noise, as shown in the figure. There are two touches as follows:</p>
<ul>
<li>The first one is shorter.</li>
<li>The second touch is longer. The instances of the touch and release events are shown in the bottom block as follows:</li>
<li>The smooth baseline signal is rising during the touch interval with the <b><em>tau_smooth_baseline</em></b> time constant.</li>
<li>The smooth baseline signal is falling during the release interval with an eighth of the <b><em>tau_smooth_baseline</em></b> time constant. The noise has a minimal level and it is constant all the time. Therefore, the dead band high and MBW baseline signals are constant. <div class="image">
<img src="mbw_signal.png" alt="mbw_signal.png"/>
<div class="caption">
MBW key detector signal waveform</div></div>
 </li>
</ul>
<p class="startli">The noise adaptation is shown in the next figure. The smooth filter with adjustable <b><em>tau_smooth_signal</em></b> time smooth filter parameter set to <em>50 ms</em> filters the raw measured signal. The noise is rising fluently and not crossing the dead band high level (not touched state) in the first third of the recorded time. This causes an increase in the baseline signal adaptation and the dead band level. Simultaneously, the <b><em>tau_smooth_baseline</em></b> time smooth baseline filter parameter set to <em>1000 ms</em> filters the smooth baseline. The baseline tracks the smooth baseline minimum in the <b><em>baseline_track_window</em></b> interval defined as <em>2000 ms</em>. The touch event is detected at the end of the first third of the recorded time. Because the signal crossed the deadband high level, the counters in the bottom block signal the touch instance. During the touch time frame, the baseline tracks the smooth baseline minimum in a different <b><em>baseline_track_window_touch</em></b> interval, defined as <em>8000 ms</em>, see the following figure.</p>
<div class="image">
<img src="mbw_noise.png" alt="mbw_noise.png"/>
<div class="caption">
MBW key detector - baseline adaptation by noise waveform</div></div>
 <p class="startli">During the touch time frame, the longer window interval adapts the baseline more slowly for the touch. The release event occurs at the second third of the recorded time and the noise simulated by a finger disappears a few seconds later. The release event causes the dead-band level and baseline to fall to the original raw value eight times faster (the smooth tau time parameter is an eighth of the baseline touch parameter). The dead-band high signal must be above the smooth signal to detect the touch event and the MBW baseline signal must be below or equal to the smooth signal. The dead-band high signal and the MBW baseline signal react to noise and the smooth baseline signal by a step changes with the intervals given by the parameter setting for touch or no touch states. The MBW baseline signal is adapted by finding a minimum for a <em>2000 ms</em> long window of the smooth baseline signal. The windows are adjustable parameters of the MBW key detector for touch and no-touch cases. The baseline adaptation during the active touch can be frozen by configuring the <b><em>baseline_track_window_touch</em></b> parameter set to zero. Both windows can be set to zero for no baseline adaptation (if touched) and the slowest baseline update for no-touch cases.</p>
<p class="startli">The MBW key detector implements the <b>delta limitation</b> feature. It aims to avoid the false touches created by interferences or jamming. Basically, to reduce the negative influence of the Touch library by electromagnetic interference external effects. Signal peaks are typically signaled with abnormally high values and short durations. The MBW key detector enables the detection of such peaks in the delta signals by processing the abnormalities recognized in the following cases:</p>
<ul>
<li>Delta is higher than the <b><em>delta_limit</em></b> electrode parameter.</li>
<li>Delta impulse is shorter than the cycle number in the <b><em>debounce_length</em></b> key detector parameter.</li>
</ul>
<p class="startli">To understand how signal peak elimination and limitation work, see the following waveform. The short signal peak elimination is based on replacing the signal delta with the previous not-influenced signal sample to achieve the MBW key detector, which can process typical level signal delta. If the duration exceeds the <b><em>debounce_length</em></b> cycle number, then for the rest of the peak duration the delta is limited to the <b><em>delta_limit</em></b> value if the <b><em>delta_limit</em></b> has been exceeded. Features can work independently. To enable duration filtering, both two parameters must be appropriately configured. To enable the value limitation, configure the delta_limit parameter only. If parameters are not defined or are set to zero, the feature is disabled. The <b><em>debounce_length</em></b> is the MBW key detector parameter that can be assigned to any electrode.</p>
<p class="startli">The following figure shows a single electrode signal with three software periodically inserted peaks for the release state (left part of the figure) and the touch state (right half of the figure) marked with red arrows with the same value but different pulse widths. The first and second double pulses are <em>4</em> cycles long each and the third pulse is <em>20</em> cycles long. The electrode <b><em>delta_limit</em></b> is configured as <em>500</em> value and the key detector debounce_length is set to <em>5</em> cycles. The first inserted signal from the left side demonstrates the touch event because the impulse is short but does not exceed the delta_limit value. The next inserted impulse with the first red arrow is eliminated as a delta signal because it complies with both conditions (shorter than debounce_length and higher than delta_limit). The last valid delta signal value replaces the second inserted double impulse with positive and negative deltas before the negative peak impulse. This impulse is finally processed as a touch event (the negative peak makes the touch event longer). Part of the third peak is ignored and the rest is limited to the delta limit due to duration exceeding the <b><em>debounce_length</em></b> parameter.</p>
<p class="startli">The fourth, sixth, and seventh peaks (positive, negative, and wide) are the same injected peaks as shown in the figure (left side) but with the finger touched on the electrode surface. The fourth peak signal is short enough but not high enough for short pulse elimination. The next inserted pulse marked fourth red arrow is eliminated by lengthening the last known signal value during the whole positive signal peak. The sixth inserted peak double impulse with positive and negative deltas is eliminated similar to the second inserted double impulse. This means that the last valid delta signal value replaces this peak before the negative peak impulse and causes a constant section in the delta signal. If the inserted impulse is wider than the debounce_length cycles number, the seventh peak demonstrates the delta signal limitation to the delta_limit value.</p>
<div class="image">
<img src="mbw_delta_limitation.png" alt="mbw_delta_limitation.png"/>
<div class="caption">
MBW key detector - delta signal limitation</div></div>
 </li>
</ul>
<h1><a class="anchor" id="controls_section"></a>
Controls</h1>
<p>This section describes the different <a class="el" href="group__controls.html">Controls</a> supported by the NXP Touch library.</p>
<p>The decoders provide the highest level of abstraction in the library. In this layer, the information about the touched and untouched electrodes is interpreted and it shows the status of the control in a behavioral way. The decoders also provide more functionality. &lt;Note&gt;: The decoder-related code exists only once in the memory, which implies that despite the number of rotary controls in the system, only one rotary decoder resides in the memory.&lt;/Note&gt; The decoders can be described as classes of the object-oriented language, where each control has a decoder associated with it. Therefore, the control becomes an instance of the decoder (an object). However, not all decoders are necessarily instantiated in every system. The decoder types supported by the library are as follows:</p>
<ul>
<li>Keypad</li>
<li>Analog rotary</li>
<li>Analog slider</li>
</ul>
<p>Types:</p>
<ul>
<li>aslider: The analog slider control works similarly to a standard slider but with fewer electrodes. The calculated position also has a higher resolution. For example, a two-electrode analog slider can provide an analog position in the range of 128. The shape of the electrodes must meet the condition that increases and decreases the signal during the finger movement, which must be linear. The figure shows an arrangement of electrodes used for a typical analog slider. The analog slider control provides the following callback events:<ul>
<li>direction change</li>
<li>movement</li>
<li>touch</li>
<li>release <div class="image">
<img src="aslider.png" alt="aslider.png"/>
<div class="caption">
Analog slider</div></div>
</li>
</ul>
</li>
<li>keypad: The keypad is a basic configuration for the arranged electrodes shown in the figure to determine which electrode has been touched. The keypad decoder is the module handling the boundary checking, controlling the events buffer, and reporting of events (depending on the user configuration). The keypad decoder must be used when the application needs the electrodes to behave like keyboard keys. If you must detect movement, use another type of decoder. The keypad decoder uses a group of electrodes that must be touched simultaneously to report the defined key, enabling the user to create a control interface with more user inputs than the number of physical electrodes. The keypad enables the detection of multi-touch events when more keys are touched simultaneously. The key combinations consist of two or more keys pressed together and the user can define these combinations for the group or single electrode-based keypad. The actual touched keys are compared with stored key combinations from the last key to the first key. When the same key is detected, the comparison stops and executes the callback with the multi-touch combination number. The keypad control provides the following callback events:<ul>
<li>touch</li>
<li>release</li>
<li>autorepeat</li>
<li>multi-touch</li>
</ul>
</li>
</ul>
<div class="image">
<img src="keypad.png" alt="keypad.png"/>
<div class="caption">
Keypad</div></div>
<ul>
<li>arotary: The analog rotary control is similar to the standard rotary control but with fewer electrodes. The calculated position also has a higher resolution. For example, a 4-electrode analog rotary control can provide an analog position in the range of 64. The shape of the electrodes must meet the condition that increases and decreases the signal during the finger movement, which must be linear. The figure shows an arrangement of electrodes used for a typical analog rotary control. The configuration must be the same. In other words, the electrodes intended to form a rotary slider must be placed one after another (forming a circle). The analog rotary control provides the following callback events:<ul>
<li>direction change</li>
<li>movement</li>
<li>touch</li>
<li>multi-touch</li>
<li>release <div class="image">
<img src="arotary.png" alt="arotary.png"/>
<div class="caption">
Analog rotary</div></div>
</li>
</ul>
</li>
<li>matrix: The matrix implements a functionality similar to the keypad but the matrix has the electrode surfaces placed closer to each other. Moreover, the matrix control allows processing the position tracking and gesture recognition. Usually, the matrix control is used for data processing from the touchpad hardware. The matrix control provides the following callback events:<ul>
<li>movement</li>
<li>touch</li>
<li>release</li>
<li>double tap</li>
<li>cover</li>
<li>gesture <div class="image">
<img src="matrix.png" alt="matrix.png"/>
<div class="caption">
Matrix</div></div>
</li>
<li>proxi: The proxi control enables the detection of a ﬁnger (or object) presence in the near ﬁeld of the electrode so that the approaching ﬁnger/hand can be detected without a direct electrode touch. Moreover, the proximity position and direction of the movement can be evaluated for each proximity electrode. The proxi control provides the following callback events:</li>
<li>movement</li>
<li>touch</li>
<li>release</li>
<li>gesture <div class="image">
<img src="proxi.png" alt="proxi.png"/>
<div class="caption">
Proxi</div></div>
 </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="grounding_of_adjacent_TSI_channels"></a>
Grounding or shielding of adjacent TSI channels</h2>
<p>The feature improves the TSI measurement so that all electrodes assigned to the control are grounded except the electrode currently being measured. This leads to better crosstalk and sensitivity as shown in the following figure for mutual sensing-based keypad control. Ensure not to use this feature for analog controls like analog slider, analog rotary, or proxi controls due to touch sensing degradation. This degradation is the worst ratio of electrode delta signals assigned to the control. The <b><em>adjacent_electrodes</em></b> parameter can be enabled separately for each control (recommended for keypad, slider, rotary, or matrix, not suitable for aslider or arotary ). For each electrode of the control, configure the <b><em>pin_input</em></b> and <b><em><a class="el" href="group__electrodes.html#structgpio__inputs">gpio_inputs</a></em></b> parameters.</p>
<p>The devices based on the MKE17Z9 (MKE17Z512) family have an extra shielding feature. This feature improves the TSI measurement by shielding the unmeasured TSI channels. Instead of ground connection, the selected unmeasured electrodes are changed to the HW shielding electrodes during the touch measurement. If the shielding feature is enabled (adjacent_electrodes = kAdj_shielding), the electrodes, which are not measured and are assigned to the control, are changed to HW shielding electrodes by modification of the TSI SHIELD register. The user can configure <b><em>shield_mask</em></b> electrode parameter, where the bits relay the TSI channels. The parameter from the measured electrode is applied during a new measurement trigger process to reconfigure the SHIELD register defining the shielding electrodes. The shield_mask parameter defines several electrodes to be shielded whether the electrodes are assigned to the control or not. However, the shielding mask is applied to the SHIELD register only when the electrodes assigned to the control with the shielding feature enabled are triggered for measuring.</p>
<div class="image">
<img src="gndAdjacent.png" alt="gndAdjacent.png"/>
<div class="caption">
Grounding of adjacent TSI channels</div></div>
<h1><a class="anchor" id="electrodes_section"></a>
Electrodes</h1>
<p>The electrodes are data objects that are used by data-acquisition algorithms to store per-electrode data, the resulting signal, and the touch/timestamp information. Each electrode provides a signal value information. The baseline value and the touch/timestamp buffer contain the time of the last few touch and release events. The electrode also contains information about the key detector used to detect touches for this physical electrode. This gives the advantage that each electrode has its settings of the key detector (independent of the module used). It contains information about the hardware pin, the immediate touch status, and the time stamps of the last few touch or release events. The private electrodes API provides all the functionality needed to handle the private needs of the NXP Touch library.</p>
<p>As the application programmer and NXP Touch library user, you must specify what modules and controls are going to be instantiated in the system and what electrodes each module services. This document provides more details about the various modules and their configuration. The information about the enabled electrodes and the assigned TSI channel are newly stored in each electrode as a specific flag. This approach allows access to the same TSI channel by more electrodes (TSI v5 only) or uses a different hardware TSI configuration for each electrode (TSI v5 only).</p>
<p>In TSI v4, 16 input channels use the self-capacitance measurement only. In TSI v5, 25 input channels use the self-capacitance measurement and some of these channels can be used for the mutual-capacitance measurement. The number of channels to be used for the mutual-capacitance sensing depends on the TSI v5 specification and it can change from device to device (ke15z has 4 RX and 4 TX channels, ke16z has 6 RX and 6 TX channels). There can be 16 or 36 mutual-capacitance electrodes plus the rest of the self-capacitance electrodes. The number of remaining electrodes is 16 or 12 self-capacitance sensing electrodes. The lower 25 channels describe the self-capacitance electrodes. In the ke16z device, the TSI channels from 0 to 5 can be configured as the TX electrodes during the mutual-capacitance measurements. The TSI channels from 6 to 11 can be configured as the RX electrodes during the mutual-capacitance measurements, so there can be up to 36 mutual-capacitance electrodes. The channels from 25 to 60 describe the mutual-capacitance electrodes; for example, channel 61 describes the mutual electrode formed by TX2 and RX10.</p>
<p>A conflict can occur when one channel is used for both the self-capacitance electrode and the RX/TX mutual-capacitance electrode. Such a case causes the NT_ASSERT error. The NT_TSI_TRANSFORM_MUTUAL macro can be used to define the mutual-capacitance electrodes easily.</p>
<h1><a class="anchor" id="drivers_section"></a>
Drivers</h1>
<p>There are several versions of the TSI periphery. Each version of the TSI has a different set of registers and a different functionality.</p>
<h2><a class="anchor" id="tsi_v4_driver"></a>
TSI v4</h2>
<p>The TSI v4 module is a simplified version of the TSI v2 module with some additional features. It is implemented in the KE32L2A4a Arm Cortex-M0+ MCU. This kind of TSI module measures just one enabled electrode in one measurement cycle and provides automatic triggering externally, using the RTC or LPTMR timer. For more information about the TSI module features, see the reference manual of the MCU containing the TSI module.</p>
<h2><a class="anchor" id="tsi_v5_v6_driver"></a>
TSI v5/v6</h2>
<p>The electrode capacitance change causes a voltage difference change at the input of the transconductance amplifier. The amplifier converts the voltage difference to a direct current. This current is integrated as a voltage on the integration capacitor from Vm to Vp, creating a sawtooth signal. The period of the sawtooth signal depends on the electrode capacity. The TSI counter counts the TSI clock for one or several periods of the sawtooth signal. The TSI counter value then depends on the electrode capacity. TSI v5 or v6 supports self-capacitance measurements when only one TSI channel is used for one electrode. TSI v5 or v6 also adds the mutual-capacitance measurements where two electrodes (RX, TX) are used for one electrode. The TSI mutual channels can be combined into a matrix to increase the number of electrodes. The TSI v5 or v6 module measures just one electrode in one measurement cycle and enables the software or hardware trigger to start a scan.</p>
<p>The new software feature (implemented in the TSI v5 or v6 module only) develops the configuration capabilities by enabling more parameters to be defined for each electrode. The tsi_hw_config item pointing to the <a class="el" href="namespace_3global_scope_4.html#structtsi__config__t">tsi_config_t</a> data type structure expands the configuration structure of the electrode, containing all hardware settings for the TSI v5 or v6 module. The TSI v5 or v6 module is always reconfigured to measure the channel capacitance value according to the specific (or default) TSI hardware configuration. If different electrode dimensions are targeted, this feature enables you to set the specific sensitivity, sample time, or other parameters given by the application without any limitations. The same TSI channel can be used for more electrodes with different hardware configurations, key detectors, or other parameters for tuning purposes. If the tsi_hw_config item is not defined for a specific electrode, the initialization process assigns the default TSI configuration (from the config member of the <a class="el" href="group__gmodules.html#structnt__module">nt_module</a> structure).</p>
<div class="image">
<img src="tsi_v5.png" alt="tsi_v5.png"/>
<div class="caption">
TSI peripheral version 5</div></div>
<div class="image">
<img src="tsi_v6.png" alt="tsi_v6.png"/>
<div class="caption">
TSI peripheral version 6</div></div>
<h2><a class="anchor" id="cs_driver"></a>
CS</h2>
<p>The Capacitive Sense (CS) determines the proximity and touch detection based on self-capacitance. As a finger comes in contact with a touchpad, the change in capacitance is measured between the input channel and the ground. This is accomplished using a relaxation oscillator that increments a counter every cycle. When there is no contact on the touchpad, the relaxation oscillator oscillates at a user-configurable frequency based on the parasitic capacitance of the system. When a finger makes contact, the total capacitance increases, causing the frequency of the oscillator to drop. It will cause the counter output to be noticeably lower than when there is no contact with the touchpad. Touch events are determined by observing the change in the counter output.</p>
<div class="image">
<img src="cs.png" alt="cs.png"/>
<div class="caption">
CS peripheral</div></div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 2 2024 08:33:26 for NXP Touch Library Reference Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
